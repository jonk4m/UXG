include in the manual that the user must create the fpcs prior to creating the signals or else they won't be able to select the pattern that each signal corresponds to 
include in manual that you don't have to type hz or degrees everytime 
include in manual why you can't just download an fpcs file from the web ftp and then it will say the header is wrong. (it's because you have to import from my application so the application can rewrite the header)
include in manual why you decided not to include functionality for batch files - user can simply create a blank csv using the program, then type in what they want manually (biggest hassle would be just converting their pattern to hex and making sure they all trailing not leading zeros) 
include in manual what broken out code is specifically for ftp

Test that executable works
get everything together in your backpack tonight - laptop, charger, token, ID badge, phone charger, ethernet cord
--------------------------------------Test that feeding it to the UXG works after all the changes you've made this week
Barker codes
Write code for feeding in a YATG file
--------------------------------------implement "delete table from UXG" button 
finish "connect to uxg" tab
--------------------------------------decide on what to do about signal creator tab
go through todo's in the code
--------------------------------------add functionailty to edit previous patterns in a table
meet with Jeremy and Dave
--------------------------------------Make table visualization 
--------------------------------------add "clear" button for pattern editing so the current pattern is cleared
figure out why uniform noise doesn't just happen at the one specified freq
double check that freq entries are relative not absolute
--------------------------------------make the state of the first pattern be "off"
--------------------------------------fix the hex conversion so it doesn't chop off bits? 
add in code that lets the user know the max phase value allowed is 180
add in code that tells the user if they've reached the 512 max patterns for batch file entry
--------------------------------------add a "delete all files on uxg" button to the connect to UXG tab
figure out how to retrieve and parse diagnostic info from the UXG (prolly using status register) to know how it's doing as well as knowing when a file is finished playing for the rotor to know
allow user to select a file from the UXG to edit, then add functionality so when they upload it first deletes the old one of that name
--------------------------------------Add these SCPI commands to happen after the ftp process uploads a file:
Allow user to choose from list of hostnames or IP's in the "connect to UXG" tab for choosing the current UXG
Using :MEMory:FREE[:ALL]? have the code check if there's enough room on the UXG for the file before uploading it (there's got to be a function with QFile to check the size and make sure there's enough room comparing that size)
Have a startup function routine that does things like turn the display off, turn Modulation On, etc.
Add checks for max length of patterns and table
Add checks for resolution limits of fpcs values (0.01 degree resolution, 1kHz resolution) 
--------------------------------------Add a self-test button on the connect page
--------------------------------------Add a power-off button to the connect page
Add checks for the user inputs that they're in fact numbers when we expect them to be 
change all the qDebug()'s to output on the text window at the bottom of the page

C:\Users\abms1\Desktop\UXG\build-UXG-Desktop_Qt_5_15_0_MSVC2019_64bit-Debug

On the documentation User's Guide/Streaming Mode Use/FrequencyPhase Coding Files  at the top, the third "NOTE" down says "This topic does not apply to Streaming when File is the Streaming Source selection." So wtf do we use as a reference for that?
It appears I should be using FPC not FPCS since FPCS is for FCP operation whereas FPC is for streaming. 


TODO
add a text window BELOW the main tabs so it persists for every page and change all the qDebug()'s to output on that text window

SETTING AN FPCS FILE TO BE THE CURRENT TABLE DOES NOTHING. THE VALUES OF THE CURRENT TABLE DON'T CHANGE. YOU HAVE TO IMPORT FROM THE FPCS FILE FOR THE CURRENT TABLE'S VALUES TO MATCH THE FILE'S 

:MEMory:EXPort:ASCii:FPCSetup "testFile.fpcs" WILL ALWAYS OUTPUT THE FILE AS A CSV EVEN IF YOU TELL IT TO DO IT AS AN FPCS (THAT COMES STRAIGHT FROM THE DOCUMENTATION)
SO HOW DO I GO FROM A CSV TO AN FPCS???? WHY ISN'T THERE A :MEMory:STORE:ASCii:FPCSetup "testFile.fpcs"  SCPI COMMAND? There is, it's SOURce:PULM:STReam:FPCSetup:STORe



newEntry.numOfPhasesOrFreqs = window_fpcs.workingEntryList.at(highlightedFpcsRow).numOfPhasesOrFreqs;
on_socket_readyRead()



LET'S NOT CREATE THE CSV FILE UNTIL RIGHT BEFORE WE UPLOAD IT TO THE UXG. IF WE DOWNLOAD A CSV, WE PARSE THE VALUES INTO OUR FPCS CLASS THEN DELETE THE FILE, THEN CREATE A FILE

WHEN WE CLOSE THE PROGRAM WE POPULATE THE CSV FILE REGARDLESS OF UPLOADING 


INCLUDE IN PRESENTATION THE ISSUE YOU RAN INTO WITH THE TRAILING ZEROS FOR THE HEX CONVERSION OF THE BITPATTERN. SINCE THE UXG READS THE PATTERN IN TRANSMISSION ORDER, A PATTERN OF 110 NEEDS TO HAVE A TRAILING ZERO (1100) FOR THE HEX CONVERSION, NOT A LEADING ZERO (0110) SINCE IT STARTS READING FROM THE FRONT OF THE PATTERN NOT THE BACK. AKA THAT TRAILING ZERO WILL BE IGNORED
	
	
0000000100100011010001010110011110001001101010111100110111101111 both - 4 bits
	length is 64
010 phase only - 2 bits 
00011011 freq only - 4 bits 




SELECT EXISTING TABLE FROM THE UXG 


window_ftpManager->downloadState = settingCurrentTable;
	//select the chosen table to be the current table on the UXG
send_SPCI(:SOURce:PULM:STReam:FPCSetup:SELect fileName);

window_ftpManager->downloadState = exportingTable;
// export the current table to a csv
send_SCPI(:MEMory:EXPort:ASCii:FPCSetup fileName) 

window_ftpManager->current_state = FtpManager::state::downloading;
window_ftpManager->start_process(window_fpcs.settings.existingTableFilePath);


---> on_ready_read() 

if(window_ftpManager->downloadState == window_ftpManager->settingCurrentTable)
	window_ftpManager->downloadState = exportingTable;
	send_SCPI(:MEMory:EXPort:ASCii:FPCSetup fileName)

else if(window_ftpManager->downloadState == window_ftpManager->exportingTable)
	window_ftpManager->downloadState = window_ftpManager->finished;
	//pre_initialize_uxg_file();
	
	
	




window_ftpManager->downloadState = settingCurrentTable;
:SOURce:PULM:STReam:FPCSetup:SELect  window_fpcs.settings.existingTableFilePath.append(".fpcs")
send

window_ftpManager->downloadState = exportingTable;
:MEMory:EXPort:ASCii:FPCSetup  window_fpcs.settings.existingTableFilePath.append(".csv")
send

window_ftpManager->downloadState = finished;
window_ftpManager->current_state = FtpManager::state::downloading;
window_ftpManager->start_process(window_fpcs.settings.existingTableFilePath);




















